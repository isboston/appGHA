name: Workflow notify

on:
  schedule:
    - cron: "30 6 * * *"
  workflow_dispatch:

jobs:
  check-failed-workflows:
    runs-on: ubuntu-latest
    steps:
      - name: Notify failed runs
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          WORKFLOWS: |
            appGHA|ci-oci.yml
            appGHA|test2.yml
            appGHA|check-wo.yml
            appGHA|tg_notify.yml
            appGHA2|test.yml
        run: |
          # Use associative arrays to track statuses and messages
          declare -A REPO_STATUS
          declare -A REPO_COUNT

          while IFS='|' read -r REPO WORKFLOW; do
            [[ -z "$REPO" || -z "$WORKFLOW" ]] && continue
            
            FULL_REPO="isboston/$REPO"
            API_URL="https://api.github.com/repos/$FULL_REPO/actions/workflows/$WORKFLOW/runs?per_page=30"
            
            # Get runs info
            RESPONSE="$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" "$API_URL")"
            if ! echo "$RESPONSE" | jq -e .workflow_runs >/dev/null 2>&1; then
              echo "Error API: $FULL_REPO/$WORKFLOW"
              continue
            fi
            
            # Filter runs for the last 24h and specific branches
            RUNS="$(echo "$RESPONSE" | jq --arg start "$(date -u -d '24 hours ago' +%Y-%m-%dT%H:%M:%SZ)" \
              '[.workflow_runs[]
                | select(.created_at >= $start)
                | select(.head_branch | test("^(main|release/.+|hotfix/.+|develop)$"))]')"

            # Count fails/success
            FAIL_COUNT="$(echo "$RUNS" | jq '[.[] | select((.conclusion? // "failure") | test("failure|failed|error|startup_failure"))] | length')"
            SUCCESS_COUNT="$(echo "$RUNS" | jq '[.[] | select(.conclusion == "success")] | length')"

            if (( FAIL_COUNT > 0 )); then
              STATUS="âŒ"
            elif (( SUCCESS_COUNT > 0 )); then
              STATUS="âœ…"
            else
              # Skip if no fails and no successes
              continue
            fi

            # Build lines with escaped underscores
            # Escape underscores in name, URL, branch to avoid Telegram Markdown parsing error
            LINES="$(echo "$RUNS" | jq -r '[.[] |
              "\u25FB [\(.name|gsub("_"; "\\_")|.[0:29] + (if .name|length>26 then "..." else "" end))](\(.html_url|gsub("_"; "\\_"))) (\(.head_branch|gsub("_"; "\\_")))"
            ] | join("\n")')"

            # Append info to arrays
            REPO_STATUS["$REPO"]+="$STATUS $WORKFLOW\n$LINES\n"
            (( REPO_COUNT["$REPO"] += FAIL_COUNT > 0 ? FAIL_COUNT : 0 ))
          done <<< "$WORKFLOWS"

          # Aggregate final text
          RESULT=""
          for REPO in "${!REPO_STATUS[@]}"; do
            COUNT="${REPO_COUNT[$REPO]}"
            HEADER="ðŸš€ REPO: $REPO"
            [[ "$COUNT" -gt 0 ]] && HEADER="âŒ $COUNT FAILED | 24h | $HEADER"
            RESULT+="$HEADER\n${REPO_STATUS[$REPO]}\n"
          done

          # If there's something to send, send to Telegram
          if [[ -n "$RESULT" ]]; then
            # Ð­ÐºÑ€Ð°Ð½Ð¸Ñ€ÑƒÐµÐ¼ ÐºÐ°Ð²Ñ‹Ñ‡ÐºÐ¸, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð½Ðµ Ð»Ð¾Ð¼Ð°Ñ‚ÑŒ JSON
            RESULT_ESCAPED="${RESULT//\"/\\\"}"
            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -H "Content-Type: application/json" \
              -d "{\"chat_id\": \"${TELEGRAM_CHAT_ID}\",
                   \"text\": \"$RESULT_ESCAPED\",
                   \"parse_mode\": \"Markdown\",
                   \"disable_web_page_preview\": true}"
          fi
